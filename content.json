{"meta":{"title":"ActiveBlog","subtitle":"Action speak louder than words.","description":"Action speak louder than words.","author":"苗世科","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-06-30T03:55:49.517Z","updated":"2017-06-30T03:55:49.502Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"关于我","date":"2017-06-30T03:52:00.000Z","updated":"2017-07-19T05:43:18.581Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"基本资料&emsp;&emsp;昵&emsp;&emsp;称：&emsp;ActiveBlog &emsp;&emsp;性&emsp;&emsp;别：&emsp;男 &emsp;&emsp;现居住地：&emsp;陕西·西安 &emsp;&emsp;Q&emsp;&emsp;Q：&emsp;1522648649 &emsp;&emsp;Hey,我是MSK ，还是一个在校大学生，主要学习方向为java后台开发，网页前端学习。希望通过Blog纪录自己学习的过程，也欢迎同在科技之海寻找方向与解答的大家一起成长^_^&emsp;&emsp;这里会分享一些小小的教学及不错的资源，同时请大家不吝指教～ 与此同时，也会分享一些生活的点点滴滴。 Action speak louder than words.行动胜于言语（行胜于言）"},{"title":"tags","date":"2017-06-30T03:46:32.000Z","updated":"2017-06-30T03:47:08.426Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-06-30T03:50:04.000Z","updated":"2017-06-30T03:51:43.240Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"ArrayList简介及扩容机制","slug":"ArrayList简介及扩容机制","date":"2017-08-31T12:10:49.000Z","updated":"2017-08-31T12:17:23.289Z","comments":true,"path":"2017/08/31/ArrayList简介及扩容机制/","link":"","permalink":"http://yoursite.com/2017/08/31/ArrayList简介及扩容机制/","excerpt":"ArrayList介绍ArrayList 是一个数组队列，相当于动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。","text":"ArrayList介绍ArrayList 是一个数组队列，相当于动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。 ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。 ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。 &emsp;&emsp;和Vector不同，ArrayList中的操作不是线程安全的。所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。 ArrayList的继承关系 ArrayList构造函数123456// 默认构造函数ArrayList()// capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。ArrayList(int capacity)// 创建一个包含collection的ArrayListArrayList(Collection&lt;? extends E&gt; collection) 扩容机制&emsp;&emsp;首先大家都知道ArrayList的扩容规则是变成原来最大容量的1.5倍。&emsp;&emsp;你也可以通过eclipse等IDE打开ArrayList.add()的源码查看。 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 通过ensureCapacityInternal方法判断是否要扩容。源码如下： 123456789101112131415161718 /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. * EMPTY_ELEMENTDATA是空数组，表示现在ArrayList是空的 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;////elementData是存放元素的对象数组 transient Object[] elementData; // non-private to simplify nested class access private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; &emsp;&emsp;ensureCapacityInternal（确保内部容量）中首先是判断现在的ArrayList是不是空的，如果是空的，minCapacity就取默认的容量和传入的参数minCapacity中的大值,然后调用ensureExplicitCapacity方法。 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; //如果数组（elementData)的长度小于最小需要的容量（minCapacity）就扩容 // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; &emsp;&emsp;如果minCapacity的值大于add数据之前的大小，就调用grow方法，进行扩容，否则什么也不做。&emsp;&emsp;增长机制是通过grow方法实现的。 1234567891011121314151617 /***增加容量，以确保它至少能容纳*由最小容量参数指定的元素数。* @param mincapacity所需的最小容量*/private void grow(int minCapacity) &#123;//minCapcatiy的值是size+1 // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //&gt;&gt;位运算，右移动一位。 整体相当于newCapacity =oldCapacity + 0.5 * oldCapacity if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; &emsp;&emsp;实现grow方法调用就肯定是(size+1)&gt;elementData.length的情况，所以size就是初始最大容量或上一次扩容后达到的最大容量，所以才会进行扩容。 &emsp;&emsp;newCapacity=oldCapacity+(oldCapacity&gt;&gt;1)，这里就是扩容大小确定的地方，相当于新的最大容量是 size+1+size/2 相当于原来的1.5倍 。 这样便实现了ArrayList的自动扩容。 总结 注意其三个不同的构造方法。无参构造方法构造的ArrayList的容量默认为10，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。 注意扩充容量的方法ensureCapacity。ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。 ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。 在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。 参考资料：http://blog.csdn.net/u010176014/article/details/52073339","categories":[{"name":"java知识总结","slug":"java知识总结","permalink":"http://yoursite.com/categories/java知识总结/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"http://yoursite.com/tags/ArrayList/"},{"name":"求职","slug":"求职","permalink":"http://yoursite.com/tags/求职/"}]},{"title":"HashMap的工作原理","slug":"HashMap的工作原理","date":"2017-08-31T12:04:41.000Z","updated":"2017-08-31T12:18:21.610Z","comments":true,"path":"2017/08/31/HashMap的工作原理/","link":"","permalink":"http://yoursite.com/2017/08/31/HashMap的工作原理/","excerpt":"&emsp;&emsp;HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！","text":"&emsp;&emsp;HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！ 先来些简单的问题 “你用过HashMap吗？” “什么是HashMap？你为什么用到它？” &emsp;&emsp;几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题： “你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？” &emsp;&emsp;你也许会回答“我没有详查标准的Java API，你可以看看Java源代码或者Open JDK。”“我可以用Google找到答案。” &emsp;&emsp;但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。 下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法： “当两个对象的hashcode相同会发生什么？” &emsp;&emsp;从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。 但故事还没有完结，面试官会继续问： “如果两个键的hashcode相同，你如何获取值对象？” &emsp;&emsp;面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者知道HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。 其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！ 许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。 如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。 “如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？” &emsp;&emsp;除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。 如果你能够回答这道问题，下面的问题来了： “你了解重新调整HashMap大小存在什么问题吗？”你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。 &emsp;&emsp;当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？ 热心的读者贡献了更多的关于HashMap的问题： 为什么String, Interger这样的wrapper类适合作为键？ &emsp;&emsp;String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。 我们可以使用自定义的对象作为键吗？ &emsp;&emsp;这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。 我们可以使用CocurrentHashMap来代替Hashtable吗？ &emsp;&emsp;这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。看看这篇博客查看Hashtable和ConcurrentHashMap的区别。我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点： hashing的概念HashMap中解决碰撞的方法equals()和hashCode()的应用，以及它们在HashMap中的重要性不可变对象的好处HashMap多线程的条件竞争重新调整HashMap的大小 总结 HashMap的工作原理 &emsp;&emsp;HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。 当两个不同的键对象的hashcode相同时会发生什么？ &emsp;&emsp;它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。 因为HashMap的好处非常多，我曾经在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到HashMap和ConcurrentHashMap。你可以查看更多的关于HashMap的文章: HashMap和Hashtable的区别HashMap和HashSet的区别 原文链接： Javarevisited 翻译： ImportNew.com - 唐小娟 译文链接： http://www.importnew.com/7099.html","categories":[{"name":"java知识总结","slug":"java知识总结","permalink":"http://yoursite.com/categories/java知识总结/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"http://yoursite.com/tags/ArrayList/"},{"name":"求职","slug":"求职","permalink":"http://yoursite.com/tags/求职/"}]},{"title":"[Leetcode] Maximum and Minimum Depth of Binary Tree 二叉树的最小最大深度【java】","slug":"Leetcode-Maximum-and-Minimum-Depth-of-Binary-Tree-二叉树的最小最大深度【java】","date":"2017-08-08T13:08:22.000Z","updated":"2017-08-08T13:15:03.442Z","comments":true,"path":"2017/08/08/Leetcode-Maximum-and-Minimum-Depth-of-Binary-Tree-二叉树的最小最大深度【java】/","link":"","permalink":"http://yoursite.com/2017/08/08/Leetcode-Maximum-and-Minimum-Depth-of-Binary-Tree-二叉树的最小最大深度【java】/","excerpt":"题目描述&emsp;&emsp;Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.","text":"题目描述&emsp;&emsp;Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Maximum Depth of Binary Tree递归法复杂度&emsp;&emsp;时间 O(N) 空间 O(H) 递归栈空间 思路&emsp;&emsp;简单的递归。递归条件是，它的最大深度是它左子树的最大深度和右子树最大深度中较大的那个加1。基础条件是，当遇到空节点时，返回深度为0。该递归的实质是深度优先搜索。 代码1234567891011public class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left, right) + 1; &#125;&#125; Minimum Depth of Binary Tree递归法复杂度时间 O(N) 空间 O(H) 递归栈空间 思路当求最大深度时，我们只要在左右子树中取较大的就行了，然而最小深度时，如果左右子树中有一个为空会返回0，这时我们是不能算做有效深度的。所以分成了三种情况，左子树为空，右子树为空，左右子树都不为空。当然，如果左右子树都为空的话，就会返回1。 代码123456789101112131415161718public class Solution &#123; public int minDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; int depth = 0; if(root.left != null &amp;&amp; root.right != null)&#123; int left = minDepth(root.left); int right = minDepth(root.right); depth = Math.min(left, right); &#125; else if (root.left != null)&#123; depth = minDepth(root.left); &#125; else if (root.right != null)&#123; depth = minDepth(root.right); &#125; return depth + 1; &#125;&#125; 广度优先搜索复杂度时间 O(N) 空间 O(B) 思路递归解法本质是深度优先搜索，但因为我们是求最小深度，并不一定要遍历完全部节点。如果我们用广度优先搜索，是可以在遇到第一个叶子节点时就终止并返回当前深度的。 代码1234567891011121314151617181920public class Solution &#123; public int minDepth(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); if(root!=null) queue.offer(root); int depth = 0; while(!queue.isEmpty())&#123; int size = queue.size(); depth++; for(int i = 0; i &lt; size; i++)&#123; TreeNode curr = queue.poll(); if(curr.left == null &amp;&amp; curr.right == null)&#123; return depth; &#125; if(curr.left != null) queue.offer(curr.left); if(curr.right != null) queue.offer(curr.right); &#125; &#125; return depth; &#125;&#125; 本文参考segmentfault中文章","categories":[{"name":"编程基础","slug":"编程基础","permalink":"http://yoursite.com/categories/编程基础/"}],"tags":[{"name":"二叉树的最小最大深度","slug":"二叉树的最小最大深度","permalink":"http://yoursite.com/tags/二叉树的最小最大深度/"}]},{"title":"MVC框架基础","slug":"MVC简介","date":"2017-07-19T09:02:29.000Z","updated":"2017-07-19T09:08:19.258Z","comments":true,"path":"2017/07/19/MVC简介/","link":"","permalink":"http://yoursite.com/2017/07/19/MVC简介/","excerpt":"MVC简介&emsp;&emsp;MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。","text":"MVC简介&emsp;&emsp;MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 MVC 编程模式 Model（模型）表示应用程序核心（比如数据库记录列表）。是应用程序中用于处理应用程序数据逻辑的部分。 通常模型对象负责在数据库中存取数据。 View（视图）显示数据（数据库记录）。是应用程序中处理数据显示的部分。 通常视图是依据模型数据创建的。 Controller（控制器）处理输入（写入数据库记录）。是应用程序中处理用户交互的部分。 通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。javaEE经过多年的发展，形成的开发体系。 模型Model1简介：Model2简介(MVC模型)框架和设计模式的区别&emsp;&emsp;框架、设计模式这两个概念总容易被混淆，其实它们之间还是有区别的。框架通常是代码重用，而设计模式是设计重用，架构则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。在软件生产中有三种级别的重用：内部重用，即在同一应用中能公共使用的抽象块;代码重用，即将通用模块组合成库或工具集，以便在多个应用和领域都能使用；应用框架的重用，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性。&emsp;&emsp;框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。可以说，框架是软件，而设计模式是软件的知识。框架模式有哪些？&emsp;&emsp;MVC、MTV、MVP、CBD、ORM等等；框架有哪些？&emsp;&emsp;C++语言的QT、MFC、gtk，Java语言的SSH 、SSI，php语言的 smarty(MVC模式)，python语言的django(MTV模式)等等。设计模式有哪些？ &emsp;&emsp;工厂模式、适配器模式、策略模式等等 &emsp;&emsp;简而言之：框架是大智慧，用来对软件设计进行分工；设计模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度。 &emsp;&emsp;博主知识有限。如果有任何遗漏或者错误，欢迎指正！谢谢~~~&emsp;&emsp;转载请注明出处！","categories":[{"name":"MVC框架","slug":"MVC框架","permalink":"http://yoursite.com/categories/MVC框架/"}],"tags":[{"name":"MVC简介","slug":"MVC简介","permalink":"http://yoursite.com/tags/MVC简介/"}]},{"title":"Servlet基础（二）：Servlet与JSP","slug":"Servlet基础（二）：Servlet与JSP","date":"2017-07-19T05:25:38.000Z","updated":"2017-07-19T05:27:47.547Z","comments":true,"path":"2017/07/19/Servlet基础（二）：Servlet与JSP/","link":"","permalink":"http://yoursite.com/2017/07/19/Servlet基础（二）：Servlet与JSP/","excerpt":"JSP简介&emsp;&emsp;JSP是一种脚本语言，包装了Java Servlet系统的界面，简化了Java和Servlet的使用难度，同时通过扩展JSP标签(TAG)提供了网页动态执行的能力。","text":"JSP简介&emsp;&emsp;JSP是一种脚本语言，包装了Java Servlet系统的界面，简化了Java和Servlet的使用难度，同时通过扩展JSP标签(TAG)提供了网页动态执行的能力。 Servlet简介&emsp;&emsp;见Servlet基础（一） Servlet与JSP的比较：联系 JSP第一次运行的时候会编译成Servlet，驻留在内存中以供调用。 JSP是web开发技术，Servlet是服务器端运用的小程序，我们访问一个JSP页面时，服务器会将这个JSP页面转变成Servlet小程序运行得到结果后，反馈给用户端的浏览器。 都可以生成动态网页。 在一个标准的MVC架构中，Servlet作为Controller接受用户请求并转发给相应的Action处理，JSP作为View主要用来产生动态页面，EJB作为Model实现你的业务代码。区别 Servlet主要用于转向，将请求转向到相应的JSP页面。 JSP的优点是擅长于网页制作，生成动态页面比较直观，缺点是不容易跟踪与排错。 Servlet是纯Java语言，擅长于处理流程和业务逻辑，缺点是生成动态网页不直观。 JSP技术开发网站的两种模式：JSP + JavaBean；JSP + Servlet + JavaBean（一般在多层应用中, JSP主要用作表现层,而Servlet则用作控制层,因为在JSP中放太多的代码不利于维护，而把这留给Servlet来实现,而大量的重复代码写在JavaBean中）Servlet与九大内置对象 &emsp;&emsp;博主知识有限。如果有任何遗漏或者错误，欢迎指正！谢谢~~~&emsp;&emsp;转载请注明出处！","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"Servlet与JSP","slug":"Servlet与JSP","permalink":"http://yoursite.com/tags/Servlet与JSP/"}]},{"title":"Servlet基础（一）：servlet的生命周期","slug":"Servlet基础（一）：servlet的生命周期","date":"2017-07-19T05:21:22.000Z","updated":"2017-07-19T09:05:46.025Z","comments":true,"path":"2017/07/19/Servlet基础（一）：servlet的生命周期/","link":"","permalink":"http://yoursite.com/2017/07/19/Servlet基础（一）：servlet的生命周期/","excerpt":"&emsp;&emsp;详情请查看个人博客Servlet基础（一） Servlet简介&emsp;&emsp;Servlet是运行在服务器的java应用程序，负责接受客户端的请求，和数据的处理，然后将结果发送给客户端的技术。&emsp;&emsp;sun公司jdk提供了一个servlet接口，然后提供了该接口的实现类HttpServlet，该Httpservlet类添加了能够解析 http协议的方法，并且重写了servlet接口的servlet方法，该方法中根据用户的http请求来判断是get提交或post提交，若get提交，调用doGet()方法，若post提交，调用doPost()方法","text":"&emsp;&emsp;详情请查看个人博客Servlet基础（一） Servlet简介&emsp;&emsp;Servlet是运行在服务器的java应用程序，负责接受客户端的请求，和数据的处理，然后将结果发送给客户端的技术。&emsp;&emsp;sun公司jdk提供了一个servlet接口，然后提供了该接口的实现类HttpServlet，该Httpservlet类添加了能够解析 http协议的方法，并且重写了servlet接口的servlet方法，该方法中根据用户的http请求来判断是get提交或post提交，若get提交，调用doGet()方法，若post提交，调用doPost()方法用户如果需要开发一个动态web资源，需要实现以下两个步骤： 编写应用程序（java类），然后继承Httpservlet重写其内部方法， 将应用程序部署到web服务器中，通过请求访问该应用程序，web服务器会调用该程序进行数 据处理。&emsp;&emsp;备注：上述应用程序即为一个servlet程序。 servlet的生命周期（运行过程）&emsp;&emsp;在GITHUB上提供了一个小项目，用来测试生命周期点击查看GitHub 在下列时刻Servlet容器装载Servlet: 方式一：Servlet容器启动时自动装载Servlet。需要在web.xml文件中添加 1234&lt;Servlet&gt; &lt;loadon-startup&gt;1&lt;/loadon-startup&gt; &lt;!-- 数字越小优先级越高 --&gt;&lt;/Servlet 方式二：客户端请求某个servlet，web服务器会接受该请求，然后根据请求来实例化某个servlet。 方式三： Servlet类文件被更新后，重新装载Servlet初始化&emsp;&emsp;然后调用其内部的init()方法，进行初始化，并且只调用一次。 响应客户请求阶段&emsp;&emsp;根据请求的数据提交方式，如果是get提交，调用doGet()方法，若post提交，调用doPost()方法。终止阶段&emsp;&emsp;当web服务器关闭时，调用其destroy()方法来销毁该servlet。 &emsp;&emsp;博主知识有限。如果有任何遗漏或者错误，欢迎指正！谢谢~~~&emsp;&emsp;转载请注明出处！","categories":[{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/categories/Servlet/"}],"tags":[{"name":"Servlet声明周期","slug":"Servlet声明周期","permalink":"http://yoursite.com/tags/Servlet声明周期/"}]},{"title":"hexo入门学习（六）：文章图片存储到七牛云","slug":"hexo入门学习（六）：文章图片存储到七牛云","date":"2017-05-12T13:12:54.000Z","updated":"2017-07-19T09:04:48.020Z","comments":true,"path":"2017/05/12/hexo入门学习（六）：文章图片存储到七牛云/","link":"","permalink":"http://yoursite.com/2017/05/12/hexo入门学习（六）：文章图片存储到七牛云/","excerpt":"&emsp;&emsp;前几天打开blog发现使用前文中的方法原方法文章中的图片莫名奇妙的挂了。查阅资料（百度、谷歌）。发现七牛云存储可以很好的解决这个问题。于是根据下面这篇文章基本解决了问题。","text":"&emsp;&emsp;前几天打开blog发现使用前文中的方法原方法文章中的图片莫名奇妙的挂了。查阅资料（百度、谷歌）。发现七牛云存储可以很好的解决这个问题。于是根据下面这篇文章基本解决了问题。参考文章:http://www.jianshu.com/p/ec2c8acf63cd來源：简书。 七牛简介&emsp;&emsp;七牛云，在这里您可以方便快捷的访问您在七牛云中使用的各类资源，通过简单操作便可以完成对相关资源的配置监控和管理。 &emsp;&emsp;一句话，我就是用它做图片托管，取外链写在文章中。OK。 注册与初识&emsp;&emsp;首先需要申请七牛账号，如果你也需要申请，请访问这个链接。注册过程比较繁琐，但是没什么难度就不啰嗦了。 &emsp;&emsp;接下来你会进到这个里面，里面有多种服务，现在只需要点击对象存储这个就可以创建空间了。 由于要使用独立域名需要账户余额大于10元。（我想免费使用所以需要使用提供的测试域名）其实还有很多配置，但是我们现在只想引用照片，所以先不考虑。 上传照片&emsp;&emsp;点击内容管理上传图片。当然这种方法比较繁琐，七牛也提供了其他的上传方法： 命令行工具 多平台同步上传客户端 &emsp;&emsp;如果你有兴趣，可以自己花时间研究一下。 引用照片&emsp;&emsp;复制外链粘贴到你想使用的地方，当然也可以使用浏览器直接打开，主要是在hexo中使用，在Markdown中采用1![image](你的外链地址) 即可看到图片。本文是简单教程，如果要求比较严苛，可以参考其它博客。或在七牛官网提供的开发者中心学习。","categories":[{"name":"hexo教程","slug":"hexo教程","permalink":"http://yoursite.com/categories/hexo教程/"}],"tags":[{"name":"hexo安装","slug":"hexo安装","permalink":"http://yoursite.com/tags/hexo安装/"}]},{"title":"hexo入门学习（五）：绑定独立域名","slug":"hexo入门学习（五）：绑定独立域名","date":"2017-05-12T12:05:36.000Z","updated":"2017-07-12T13:14:52.331Z","comments":true,"path":"2017/05/12/hexo入门学习（五）：绑定独立域名/","link":"","permalink":"http://yoursite.com/2017/05/12/hexo入门学习（五）：绑定独立域名/","excerpt":"&emsp;&emsp;到目前为止，我们的博客都是使用github分配的二级域名MSK0379.github.io来访问的， 那么我们会想如果能自己设置个域名，是多么cool的事！要怎么办呢？那就继续往下看吧!","text":"&emsp;&emsp;到目前为止，我们的博客都是使用github分配的二级域名MSK0379.github.io来访问的， 那么我们会想如果能自己设置个域名，是多么cool的事！要怎么办呢？那就继续往下看吧! 购买域名注册阿里云账户&emsp;&emsp;你可以到卖域名的网站去买一个域名，我是在万网买的域名。想买域名你要先注册阿里云的账户点击注册！如图按要求注册账户并实名认证，在此就不啰嗦了。 登陆后查询你想要的域名是否被注册&emsp;&emsp;你可以直接购买，但是也可以买阿里提供的较为划算的服务全民建站：如图送一年.xin域名。（我的就是）&emsp;&emsp;当你购买后会收到一个.xin域名的代金券，便可以在万网中购买域名。&emsp;&emsp;按照要求输入您的代金券码！获得域名之后要实名认证，按要求进行实名认证。等待几天阿里爸爸审核通过！ 域名解析&emsp;&emsp;点击对应域名的”解析”&emsp;&emsp;记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是MSK0379.github.io。&emsp;&emsp;这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：activeblog.xin。实践证明如果此时你填写的是www.activeblog.xin那么以后你只能用www.activeblog.xin访问，而如果你填写的是activeblog.xin。那么用www.activeblog.xin和activeblog.xin访问都是可以的。重新清理hexo,并发布即可用新的域名访问。至此独立网址应该成功绑定，如果有什么问题，欢迎发邮件给我，或者在文章下方评论。","categories":[{"name":"hexo教程","slug":"hexo教程","permalink":"http://yoursite.com/categories/hexo教程/"}],"tags":[{"name":"hexo安装","slug":"hexo安装","permalink":"http://yoursite.com/tags/hexo安装/"}]},{"title":"hexo入门学习（四）：文章（带图片）","slug":"hexo入门学习（四）：文章（带图片）","date":"2017-05-01T06:20:35.000Z","updated":"2017-07-12T13:14:50.835Z","comments":true,"path":"2017/05/01/hexo入门学习（四）：文章（带图片）/","link":"","permalink":"http://yoursite.com/2017/05/01/hexo入门学习（四）：文章（带图片）/","excerpt":"写作&emsp;&emsp;你可以执行下列命令来创建一篇新文章。","text":"写作&emsp;&emsp;你可以执行下列命令来创建一篇新文章。 1$ hexo new [layout] &lt;title&gt; &emsp;&emsp;您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 &emsp;&emsp;hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局 路径 post source/_posts page source draft source/_drafts 草稿&emsp;&emsp;刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。 1$ hexo publish [layout] &lt;title&gt; &emsp;&emsp;草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。 插入图片&emsp;&emsp;需要用到插件CodeFalling/hexo-asset-image。&emsp;&emsp;首先确认 _config.yml 中有 post_asset_folder:true 。&emsp;&emsp;安装此插件：在 hexo 目录，执行 1npm install https://github.com/CodeFalling/hexo-asset-image --save &emsp;&emsp;这样的目录结构（目录名和文章名一致），只要使用 （可以是gif格式）1![lbxx](hexo入门学习（三）：文章（带图片）/lbxx.jpg) 就可以插入图片。会将图片和文章生成到一个目录下。同时，生成的 html 是 1&lt;img src=&quot;/2017/7/1/hexo入门学习（三）：文章（带图片）/logo.jpg&quot; alt=&quot;logo&quot;&gt; &emsp;&emsp;执行下述代码后1hexo new &quot;hexo入门学习（四）：文章（带图片）&quot; &emsp;&emsp;得到1234hexo入门学习（三）：文章（带图片）├── lujing.png└── lbxx.jpghexo入门学习（三）：文章（带图片）.md &emsp;&emsp;显示蜡笔小新图片为下图：","categories":[{"name":"hexo教程","slug":"hexo教程","permalink":"http://yoursite.com/categories/hexo教程/"}],"tags":[{"name":"hexo安装","slug":"hexo安装","permalink":"http://yoursite.com/tags/hexo安装/"}]},{"title":"hexo入门学习（三）：主题设置","slug":"hexo入门学习（三）：主题设置","date":"2017-05-01T05:55:42.000Z","updated":"2017-07-12T13:15:02.137Z","comments":true,"path":"2017/05/01/hexo入门学习（三）：主题设置/","link":"","permalink":"http://yoursite.com/2017/05/01/hexo入门学习（三）：主题设置/","excerpt":"&emsp;&emsp;Hexo 支持个性化定制主题，可以根据自己的喜好进行修改。Hexo主题可以从官网或者GitHub查看更多主题。","text":"&emsp;&emsp;Hexo 支持个性化定制主题，可以根据自己的喜好进行修改。Hexo主题可以从官网或者GitHub查看更多主题。 一、安装主题&emsp;&emsp;在博客的根目录下打开git bash克隆主题。123git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia更改为你选择的主题地址theme/(名字。建议和原主题名一致) &emsp;&emsp;等待下载完成。执行：1vim _config.yml &emsp;&emsp;或者在 themes/你的主题/_config.yml 文件夹下使用文本编辑器打开。修改1theme: yilia（你下载的主题名称） 二、主题配置&emsp;&emsp;现在主题是更改过来了，但还有许多细节需要处理，比如说你需要修改头像等等。 首先进入到根目录下的 themes\\yilia 文件夹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111# ---------------------------------------------------------------# Site Information Settings# 网站信息配置# ---------------------------------------------------------------# Header Menu# 主菜单menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /aboutrss: /atom.xml# Set default keywords (Use a comma to separate)# 设置默认关键字keywords: &quot;&quot;# Put your favicon.ico into `hexo-site/themes/hipaper/source/` directory.# 把你的图标放在***favicon: css/images/ActiveBlog.ico# Put your avatar.jpg into `hexo-site/themes/hipaper/source/` directory.# url is target link (E.g. `url: https://hexo.io/logo.svg` or `url: css/images/mylogo.jpg`)avatar: enable: false width: 124 height: 124 bottom: 10 url: https://hexo.io/logo.svg# AboutPage background, support multiple images.# about_big_image: [css/images/pose01.jpg, https://images.unsplash.com/photo-1464306208223-e0b4495a5553?dpr=1&amp;auto=format&amp;fit=crop&amp;w=1500&amp;h=1000&amp;q=80&amp;cs=tinysrgb&amp;crop=&amp;bg=]# Homepage thumbnail# 网页的缩略图random_thumb: false# Contentfancybox: true# Sidebar# 侧边栏sidebar: rightwidgets:#- search- social- recent_posts- category- tags- tagcloud- archive# Social Links# Key is the name of FontAwsome icon.# 关键是fontawsome图标的名称。# Value is the target link (E.g. GitHub: https://github.com/MSK0379)social: Github: https://github.com/MSK0379 Envelope: mailto:17629007803@163.com # Facebook: # Google-plus: # Instagram: # Searchsearch: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: false # you need to disable other search engines to use Baidu search, options: true, false# comment ShortName, you can choose only ONE to display.duoshuo_shortname: disqus_shortname: MSK0379# Code Highlight theme# Available value:# default | normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal# widget behaviorarchive_type: &apos;monthly&apos;show_count: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/google_site_verification:baidu_site_verification:qihu_site_verification:# Miscellaneousgoogle_analytics:gauges_analytics:baidu_analytics:tencent_analytics:busuanzi_analytics: truetwitter:google_plus:fb_admins:fb_app_id: &emsp;&emsp;接着就自动部署一下：1npm install hexo-deployer-git --save &emsp;&emsp;最后发布： 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &emsp;&emsp;也可以在本地先预览以下。主题设置完毕，可以快乐玩耍啦。","categories":[{"name":"hexo教程","slug":"hexo教程","permalink":"http://yoursite.com/categories/hexo教程/"}],"tags":[{"name":"hexo安装","slug":"hexo安装","permalink":"http://yoursite.com/tags/hexo安装/"}]},{"title":"hexo入门学习（二）：关联GitHub","slug":"hexo入门学习（二）：关联GitHub","date":"2017-04-30T05:30:18.000Z","updated":"2017-07-12T13:15:00.568Z","comments":true,"path":"2017/04/30/hexo入门学习（二）：关联GitHub/","link":"","permalink":"http://yoursite.com/2017/04/30/hexo入门学习（二）：关联GitHub/","excerpt":"一.创建 Github 域名和仓库","text":"一.创建 Github 域名和仓库 注册github账户&emsp;&emsp;首先你需要注册一个注册GitHub账户 账号，已有的可以直接创建仓库，注册的话注意username，这会影响到你的域名，所以先想好用户名哦。 创建仓库&emsp;&emsp;然后需要创建一个仓库(repository) 来存储我们的网站，点击首页 New repository 按钮创建仓库, Respository name 中的 username.github.io 的 username 一定与前面的 Owner 保持一致。 二.搭建博客初始化&emsp;&emsp;所有必须工具都安装完成后，创建一个文件夹，如：Blog，用于存放hexo配置文件。然后进入文件夹Blog,执行 init 命令初始化 hexo。可议根据前一篇文章在本地预览页面。 配置Github&emsp;&emsp;现在我们需要编辑 Blog 文件夹下的 _config.yml 文件，与自己 Github 账号的 Repository 仓库建立关联。&emsp;&emsp;可以在git bash界面下输入1$ vim _config.yml &emsp;&emsp;进行修改，也可以在根目录找到_config.yml通过编辑器打开修改（推荐）。 在此推荐两款文本编辑器 notepad++ sublime Text3 &emsp;&emsp;基本配置：修改这几个必须设置的键值对，记得保存，注意配置的键值对之间一定要有空格。 1234567title: xxxx //网站标题author: xxx //作者名字language: zh-Hans //网站使用的语言 中文 deploy: type: git repo: https://github.com/username/username.github.io.git branch: master &emsp;&emsp;repo:[必须有空格] 输入您的Github创建的仓库所对应的URL链接，复制粘贴一下就OK啦 自动部署发布&emsp;&emsp;配置文件修改完成以后，执行命令，完成自动部署： 123hexo clean hexo g hexo d &emsp;&emsp;这样就将你的博客上传至你的github仓库中，可以进入你的github账户查看。在浏览器中输入 username.github.io预览。","categories":[{"name":"hexo教程","slug":"hexo教程","permalink":"http://yoursite.com/categories/hexo教程/"}],"tags":[{"name":"hexo安装","slug":"hexo安装","permalink":"http://yoursite.com/tags/hexo安装/"}]},{"title":"Hexo入门学习（一）：安装","slug":"Hexo入门学习（一）：安装","date":"2017-04-29T12:43:18.000Z","updated":"2017-07-12T13:15:03.690Z","comments":true,"path":"2017/04/29/Hexo入门学习（一）：安装/","link":"","permalink":"http://yoursite.com/2017/04/29/Hexo入门学习（一）：安装/","excerpt":"为什么要写这个关于Hexo的博客&emsp;&emsp;最近这段时间感觉搭一个属于自己的博客是一个很有意义的事情，写这个博客也是为了记录自己在学习过程中的收获，同时也留下一个学习的轨迹，或许可以帮助到其它需要的人。","text":"为什么要写这个关于Hexo的博客&emsp;&emsp;最近这段时间感觉搭一个属于自己的博客是一个很有意义的事情，写这个博客也是为了记录自己在学习过程中的收获，同时也留下一个学习的轨迹，或许可以帮助到其它需要的人。 什么是Hexo&emsp;&emsp;hexo是Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Hexo的前提工作&emsp;&emsp;安装hexo必须要安装以下两个应用程序： Node.js&emsp;&emsp;安装教程 Git&emsp;&emsp;安装教程 &emsp;&emsp;如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。您可以直接查看安装Hexo。 Windows用户安装&emsp;&emsp;对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装 Hexo新建一个文件夹，例如ActiveBlog。进入ActiveBlog文件夹，右键点击Git Bash Here。 安装Hexo 1npm install hexo-cli -g 初始化文件夹 1npm init 安装依赖和插件 1hexo install 新建完成后，指定文件夹的目录如下: 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 基础配置&emsp;&emsp;您可以在 _config.yml中修改大部份的配置。 1234567参数 描述title 网站标题subtitle 网站副标题description 网站描述author 您的名字language 网站使用的语言timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 &emsp;&emsp;其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 扩展123参数 描述theme 当前主题名称。值为false时禁用主题deploy 部署部分的设置[详情查看下一篇文章] &emsp;&emsp;更多配置查看hexo官方文档。 启动服务器进行本地预览 1hexo server(或hexo server -p 5000) &emsp;&emsp;(设置端口)我的4000端口被占用，所以使用5000。 &emsp;&emsp;打开浏览器访问http://localhost:5000访问初始化页面。 &emsp;&emsp;如有疑问欢迎点击右侧联系方式联系我。","categories":[{"name":"hexo教程","slug":"hexo教程","permalink":"http://yoursite.com/categories/hexo教程/"}],"tags":[{"name":"hexo安装","slug":"hexo安装","permalink":"http://yoursite.com/tags/hexo安装/"}]}]}